#!/usr/bin/bash
#
# refreshMgiComputed.sh
#
# For the MGI genes that don't have a gene model from a provider, generates compted models
# using Blat on selected sequences for the gene.
#
# Writes to models to stdout.
# 
#
# 0. To determine which genes have models, grep for MGI ids in the processed provider files.
#       This contrasts with the previous method, which queried the database for anything with
#       a provider ID. The problem with that approach is that genes can slip through the cracks:
#       a gene may have a provider ID, but that ID is not present in the provider data. As a result,
#       that gene ends up with no provider model, and no blatted model.
#    
# 1. Finding "good enough" sequences for each gene
#	1a. Query MGI for the genes wihtout models and their qualifying seuqnece IDs
#	1b. Download the sequences from NCBI into a fasta file.
# 2. Blatting those sequences against the mouse genome
# 3. Filtering the blat results. 
#	3a. Only sequences with a single match across the genome 
#	3b. Only matches meeting %length and %identity thresholds
# 4. Turning the blat match results into little models
#	4a. Merges the MGI data from 1a with the filtered blat results from 3b
#	4b. Creates models with the structure: gene -> match -> match_part
# 5. Writing the results to GFF3 file
#
#

source ${DIR}/bin/config.sh

# 0. Get list of MGI ids that have been assigned models so far:
grep -v "#" ${WORKINGDIR}/chr*.gff | grep -v Parent | sed "s/.*curie=\(MGI:[0-9]*\).*/\1/" | sort > ${WORKINGDIR}/genesWithModels.txt
ngwm=`wc -l ${WORKINGDIR}/genesWithModels.txt`
logit "Blat models: Counted ${ngwm} MGI ids assign to gene models."

# 1. generate a file of mgi_id/seq_id pairs.
logit "Blat models: getting MGI data..."
cat ${WORKINGDIR}/genesWithModels.txt | ${PYTHON} ${BIN}/blatPrep.py > ${WORKINGDIR}/blat.seqids.txt
checkExit

# 2a. feed the sequence ids (2nd column) to the fetch script
# this gets the sequences from ncbi and writes to a fasta file
nseqids=`wc -l ${WORKINGDIR}/blat.seqids.txt`
logit "Blat models: retrieving ${nseqids} sequences from NCBI..."
${CUT} -f 1  ${WORKINGDIR}/blat.seqids.txt | ${PYTHON} ${BIN}/seqid2fa.py - ${WORKINGDIR}/blat.seqs.fa
checkExit

# 2b. Blat the sequences against the mouse genome assembly
nseqs=`grep "^>" ${WORKINGDIR}/blat.seqs.fa | wc -l`
logit "Blat models: Blat'ing ${nseqs} sequences..."
${GFCLIENT} ${BLAT_ARGS} ${BLAT_HOST} ${BLAT_PORT} / ${WORKINGDIR}/blat.seqs.fa ${WORKINGDIR}/blat.gfclient.psl >> ${LOGFILE} 2>&1
checkExit

# 3a. Use pslreps to filter the results to single best hits
logit "Blat models: Filtering blat hits with pslreps..."
${PSLREPS} ${PSLREPS_ARGS} ${WORKINGDIR}/blat.gfclient.psl ${WORKINGDIR}/blat.pslreps.psl ${WORKINGDIR}/blat.pslreps.psr >> ${LOGFILE} 2>&1
checkExit

# 3b. Convert the alignments to GFF3 hierarchies and attach the corresponding MGI id
# Sends results to standard out. (The caller redirects to a .gff file.)
logit "Blat models: Generating models..."
${PYTHON} ${BIN}/blatMerge.py ${WORKINGDIR}/blat.pslreps.psl ${WORKINGDIR}/blat.seqids.txt 
checkExit

logit "Blat models: finished."

